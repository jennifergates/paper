module WS_HANDSHAKE;

import Spicy;

const BeforeColon = /(.|\r|\n| ).[^:]+/;
const Colon = /: /;
const DataValue = /.[^\x0d\x0a]+/;
const LineEnd = /\x0d\x0a/;
const DataEnd = b"\x53\x50\x49\x43\x59\x6a\x6c\x67";

#function to add a delimiting byte at the end of the ws packets to allow list to properly terminate
bytes terminate(b: bytes) {
	return b + DataEnd;
}

export type WS_Handshake = unit {

        get    : /^(GET|get|Get) /;
	dvalue : DataValue;
	headers : list<Header> ;
	end_of_hdrs : /\x0d\x0a\x0d\x0a/;

	ws_data : bytes &eod &convert=terminate($$) &transient -> self.sub;

	on %init {
		self.sub.connect(new Sub());
	}

	var sub: sink;
	on ws_data {
		print "\n*****ws_handshake.spicy WS_Handshake ws_data populated";
		print self.ws_data;
	}

        on %done { 
		print "\n*****ws_handshake.spicy WS_Handshake on done:"; 
		print self;
		self.sub.close();
	}
};

export type Sub = unit {
	ws_msgs : list<WS_Message>;
		    : DataEnd;
		
	on ws_msgs {
		print "\n*****ws_handshake.spicy Sub on ws_messages:";
		print self.ws_msgs;
	}
};

export type WS_Handshake_Success = unit {

        success     : /^(HTTP|http)/;
        dvalue      : DataValue;
        svrheaders     : list<Header> ;
        end_of_hdrs : /\x0d\x0a\x0d\x0a/;
        wss_data : bytes &eod &convert=terminate($$) &transient -> self.sub;

        on %init {
                self.sub.connect(new Sub());
        }

        var sub: sink;

#	on wss_message {
#		print "\n*****ws_handshake.spicy WS_Handshake_Success wss_message has data:";
#		print self.wss_message;
#	}

        on %done {
                print "\n*****ws_handshake.spicy WS_Handshake_Success on done:";
                print self;
        }
};

export type Header = unit {

		: LineEnd;
	name	: BeforeColon;
		: Colon;
	value	: DataValue;

#	on %done {
#		print "\n*****ws_handshake.spicy Header on done";
#		print self;
#	}
};

export type WS_Message = unit {
	# start with first 2 bytes as a bitfield to get access to bit level flags
        first2B: bitfield(16) {
                fin: 0;
                rsv1: 1;
                rsv2: 2;
                rsv3: 3;
                op: 4..7;
                mask: 8;
                pay1: 9..15;
        } &bitorder = Spicy::BitOrder::MSB0;
	
	# determine payload length and start point for next field
	switch ( self.first2B.pay1 ) {
		126 -> extpay: ExtPay;
		127 -> extpayc: ExtPayC;
		* -> : void;
	};
	
	# parse out masking key if payload is masked (from client)
	switch ( self.first2B.mask ) {
		1 -> maskkey: bytes &length=4;
		0 -> : void;
	};
	
	# grab the payload data. Leave unmasking to bro script
	#data: bytes &eod;
        switch ( self.first2B.pay1 ) {
                126 -> data: bytes &length=self.extpay.pay2;
                127 -> data: bytes &length=self.extpayc.pay3;
                * -> data: bytes &length=self.first2B.pay1;
        };

	on %error {
		print "\n*****ws_handshake.spicy WS_Message ERROR";
	}

	on %done {
		# feedback while coding
		print "\n*****ws_handshake.spicy WS_Message print self on done:";
		print self;
	}

};

# define this new type which parses out the extended payload length field 
export type ExtPay = unit {
	pay2: uint<16>;
	on %done {
		print "pay2 assigned";
	}
};

# define this new type which parses out the extended continued payload length field
export type ExtPayC = unit {
	pay3: uint<64>;
};