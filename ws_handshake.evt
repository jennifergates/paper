grammar ws_handshake.spicy;

protocol analyzer WS_HANDSHAKE over TCP:
    parse originator with WS_HANDSHAKE::WS_Handshake,
    parse responder with WS_HANDSHAKE::WS_Handshake_Success,
    port 9696/tcp,
    port 80/tcp,
    port 12345/tcp,
    port 44394/tcp;

on WS_HANDSHAKE::WS_Handshake->
        event ws_handshake($conn, self.headers);

on WS_HANDSHAKE::Header->
	event header($conn, self.name, self.value);

on WS_HANDSHAKE::WS_Handshake->
	event allheaders($conn, self.headers, self.dvalue);

on WS_HANDSHAKE::WS_Handshake_Success->
	event allheaders($conn, self.svrheaders, self.dvalue);

on WS_HANDSHAKE::WS_Message::first2B ->
        event ws_messages($conn, self.first2B.op, self.first2B.mask);

on WS_HANDSHAKE::WS_Message if (( self?.maskkey) && (self?.data)) ->
        event ws_maskedmessage($conn, self.first2B, self.maskkey, self.data);

#on WS_HANDSHAKE::WS_Message if ( !self?.maskkey ) ->
#	event ws_unmaskedmessage($conn, self.first2B);

#on WS_HANDSHAKE::WS_Message if (( !self?.maskkey) && (!self?.data)) ->
#	event ws_nodatamessage($conn, self.first2B);

# might need to break down further and send individual messages instead of whole list
# see hilti/bro/tests/spicy/tuple-optional.bro example for more info
#on WS_HANDSHAKE::WS_Handshake->
#	event orig_websockets($conn, self.messages);

#on WS_HANDSHAKE::WS_Handshake_Success->
#	event resp_websockets($conn, self.smessages);

#on WS_HANDSHAKE::WS_Message->
#	event ws_wmessage($conn, self.first2B, self.?maskkey, self.?data);